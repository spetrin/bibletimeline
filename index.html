



<!doctype html>



<html lang="de">



<head>



  <meta charset="utf-8" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />



  <title>Zeitleisten-Werkstatt</title>



  <style>



    :root {



      color-scheme: light;



      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;



      --panel-bg: #0f172a;



      --board-bg: rgba(248, 250, 252, 0.94);



      --line-color: #1f2937;



      --tick-color: #0ea5e9;



      --muted: #64748b;



      --shape-shadow: 0 18px 32px rgba(15, 23, 42, 0.22);



      --handle-color: rgba(14, 165, 233, 0.85);



      --handle-size: 12px;



      --arrow-green: #22c55e;



      --arrow-yellow: #facc15;



      --arrow-red: #ef4444;



    }







    *, *::before, *::after { box-sizing: border-box; }







    html, body {



      height: 100%;



      margin: 0;



    }







    body {



      display: flex;



      gap: clamp(16px, 4vw, 32px);



      padding: clamp(16px, 4vw, 32px) clamp(24px, 6vw, 56px);



      padding-left: clamp(160px, 22vw, 320px);



      background: linear-gradient(135deg, #e0f2fe, #c7d2fe 55%, #f5f3ff);



      overflow: hidden;



      color: #0f172a;



    }







    .tools-panel {



      position: fixed;



      top: clamp(24px, 5vh, 48px);



      left: clamp(24px, 5vw, 48px);



      width: clamp(140px, 18vw, 220px);



      display: grid;



      gap: 18px;



      padding: 24px;



      border-radius: 28px;



      background: rgba(15, 23, 42, 0.86);



      color: #e2e8f0;



      box-shadow: 0 32px 60px rgba(15, 23, 42, 0.35);



      backdrop-filter: blur(12px);



      z-index: 40;



    }







    .tools-panel h2 {



      margin: 0;



      font-size: 1.05rem;



      font-weight: 600;



    }







    .tools-panel__group {



      display: grid;



      gap: 12px;



    }







    .tool-button {



      display: flex;



      align-items: center;



      gap: 12px;



      border: 1px solid rgba(226, 232, 240, 0.18);



      border-radius: 18px;



      padding: 12px;



      background: rgba(15, 23, 42, 0.55);



      color: inherit;



      font-size: 0.92rem;



      font-weight: 600;



      cursor: pointer;



      transition: transform 0.2s ease, border-color 0.2s ease;



    }







    .tool-button:hover,



    .tool-button[aria-pressed="true"] {



      border-color: rgba(148, 163, 184, 0.6);



      transform: translateY(-2px);



    }







    .tool-preview {



      display: grid;



      place-items: center;



      width: 42px;



      height: 42px;



      border-radius: 14px;



      background: rgba(15, 23, 42, 0.42);



    }







    .color-palette {



      display: flex;



      gap: 10px;



    }







    .file-controls {

      display: grid;

      gap: 8px;

    }

    .file-btn {

      border-radius: 16px;

      border: 1px solid rgba(148, 163, 184, 0.35);

      background: rgba(15, 23, 42, 0.08);

      padding: 10px 14px;

      font-size: 0.9rem;

      color: inherit;

      cursor: pointer;

      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;

    }

    .file-btn:hover {

      border-color: rgba(14, 165, 233, 0.6);

      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.18);

    }

    .file-btn:active {

      transform: translateY(1px);

    }



    .color-swatch {



      width: 26px;



      height: 26px;



      border-radius: 50%;



      border: 2px solid rgba(255, 255, 255, 0.35);



      cursor: pointer;



      transition: transform 0.2s ease, border-color 0.2s ease;



    }







    .color-swatch[aria-pressed="true"] {



      transform: scale(1.05);



      border-color: #f8fafc;



    }







    .workspace-container {



      flex: 1;



      display: flex;



      flex-direction: column;



      gap: 16px;



      min-height: 0;



    }







    .workspace-toolbar {



      display: flex;



      justify-content: flex-end;



    }







    .zoom-controls {



      display: inline-flex;



      align-items: center;



      gap: 10px;



      padding: 10px 16px;



      background: rgba(15, 23, 42, 0.78);



      color: #f8fafc;



      border-radius: 999px;



      box-shadow: 0 18px 30px rgba(15, 23, 42, 0.28);



      backdrop-filter: blur(8px);



      font-size: 0.95rem;



    }







    .zoom-controls button {



      width: 32px;



      height: 32px;



      border-radius: 50%;



      border: 0;



      background: rgba(255, 255, 255, 0.2);



      color: inherit;



      cursor: pointer;



      font-size: 1.3rem;



      display: grid;



      place-items: center;



      line-height: 1;



      transition: background 0.2s ease;



    }







    .zoom-controls button:active {



      background: rgba(255, 255, 255, 0.35);



    }







    .zoom-controls input[type="range"] {



      width: clamp(120px, 20vw, 200px);



      accent-color: #38bdf8;



    }







    .zoom-controls__value {



      width: 48px;



      text-align: right;



    }







    .workspace-viewport {

      position: relative;

      flex: 1;

      border-radius: 40px;

      border: 1px solid rgba(148, 163, 184, 0.35);

      box-shadow: 0 40px 60px rgba(15, 23, 42, 0.18);

      overflow: auto;

      background: transparent;

      padding: 0 clamp(24px, 6vw, 48px);

    }







    .workspace-viewport::-webkit-scrollbar { width: 10px; height: 10px; }



    .workspace-viewport::-webkit-scrollbar-thumb {



      background: rgba(15, 23, 42, 0.35);



      border-radius: 999px;



    }







    .workspace {

      position: relative;

      width: 100%;

      min-height: 100%;

      margin: 0;

      background: var(--board-bg);

      display: flex;

      justify-content: center;

      align-items: stretch;

      padding: 0;

    }







    .workspace-canvas {



      position: relative;



      width: clamp(720px, 60vw, 1024px);



      min-height: 100%;



      transform-origin: top center;



      touch-action: none;



      display: flex;



      justify-items: center;



      justify-content: center;



    }







    .timeline-scale {

      position: relative;

      width: 160px;

      height: 400cm;

      padding: 0;

      pointer-events: none;

    }







    .timeline-scale::before {

      content: "";

      position: absolute;

      left: 50%;

      top: 0;

      bottom: 0;

      width: 4px;

      transform: translateX(-50%);

      background: linear-gradient(180deg, rgba(59, 130, 246, 0.85), rgba(15, 23, 42, 0.9));

      border-radius: 999px;

    }







    .tick {

      position: absolute;

      left: 50%;

      transform: translateY(-50%);

      display: flex;

      align-items: center;

      gap: 12px;

      color: var(--muted);

      font-size: 0.9rem;

      font-weight: 500;

      letter-spacing: 0.01em;

      white-space: nowrap;

      padding-left: 8px;

    }







    .tick__line {

      display: block;

      height: 1px;

      background: var(--tick-color);

      transition: width 0.2s ease;

      transform-origin: left center;

    }







    .tick--major .tick__line {



      width: 90px;



      height: 2px;



      background: var(--line-color);



    }







    .tick--minor .tick__line {



      width: 60px;



      opacity: 0.7;



    }







    .tick--micro .tick__line {



      width: 36px;



      opacity: 0.35;



    }







    .tick--mini .tick__line {



      width: 18px;



      opacity: 0.2;



    }







    .tick--major {



      color: #0f172a;



      font-size: 1rem;



    }







    .legend {



      position: sticky;



      top: clamp(12px, 4vh, 24px);



      align-self: center;



      background: rgba(15, 23, 42, 0.82);



      color: #f8fafc;



      padding: 10px 16px;



      border-radius: 999px;



      font-size: 0.95rem;



      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.35);



      backdrop-filter: blur(10px);



      z-index: 5;



    }







    .year-nav {



      position: fixed;



      top: 50%;



      right: clamp(16px, 4vw, 52px);



      transform: translateY(-50%);



      display: grid;



      gap: 12px;



      padding: 14px;



      border-radius: 24px;



      background: rgba(15, 23, 42, 0.82);



      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.32);



      backdrop-filter: blur(12px);



      z-index: 30;



    }







    .year-nav button {



      border: 0;



      border-radius: 16px;



      padding: 10px 14px;



      background: rgba(255, 255, 255, 0.12);



      color: #f8fafc;



      font-size: 0.9rem;



      font-weight: 600;



      cursor: pointer;



      transition: background 0.2s ease, transform 0.2s ease;



    }







    .year-nav button:hover {



      background: rgba(255, 255, 255, 0.22);



    }







    .year-nav button:active {



      transform: translateY(1px);



    }







    .shape {



      position: absolute;



      top: 0;



      left: 0;



      user-select: none;



      cursor: grab;



      z-index: 12;



      transition: box-shadow 0.2s ease;



    }







    .shape:active {



      cursor: grabbing;



    }







    .shape--selected {



      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.55);



      border-radius: 18px;



    }







    .shape__body {



      position: relative;



      width: 100%;



      height: 100%;



      pointer-events: none;



    }







    .shape__handle {



      position: absolute;



      width: var(--handle-size);



      height: var(--handle-size);



      border-radius: 50%;



      background: transparent;



      border: 0;



      opacity: 0;



      pointer-events: auto;



      transition: transform 0.15s ease;



    }







    .shape__handle:active {



      transform: scale(0.9);



    }







    .shape__handle--top,



    .shape__handle--bottom {



      cursor: ns-resize;



    }







    .shape__handle--left,



    .shape__handle--right {



      cursor: ew-resize;



    }







    .shape__handle--top {



      top: -10px;



      left: 50%;



      transform: translateX(-50%);



    }







    .shape__handle--bottom {



      bottom: -10px;



      left: 50%;



      transform: translateX(-50%);



    }







    .shape__handle--left {



      left: -10px;



      top: 50%;



      transform: translateY(-50%);



    }







    .shape__handle--right {



      right: -10px;



      top: 50%;



      transform: translateY(-50%);



    }







    .arrow-shaft {



      position: absolute;



      bottom: 0;



      left: 50%;



      width: 12px;



      transform: translateX(-50%);



      background: var(--arrow-color, var(--arrow-green));



      border-radius: 6px;



    }







    .arrow-head {



      position: absolute;



      left: 50%;



      transform: translateX(-50%);



      width: 0;



      height: 0;



      border-left: 12px solid transparent;



      border-right: 12px solid transparent;



      border-bottom: 26px solid var(--arrow-color, var(--arrow-green));



    }







    .arrow-head--bottom {



      top: auto;



      bottom: 0;



      border-bottom: none;



      border-top: 26px solid var(--arrow-color, var(--arrow-green));



    }
    .arrow-fray {
      position: absolute;
      left: 50%;
      width: 28px;
      height: 18px;
      transform: translateX(-50%);
      background: var(--arrow-color, var(--arrow-green));
      clip-path: polygon(0 100%, 0 50%, 6% 25%, 14% 65%, 22% 18%, 30% 70%, 38% 22%, 48% 68%, 58% 20%, 68% 72%, 78% 28%, 88% 60%, 95% 35%, 100% 55%, 100% 100%);
      opacity: 0.95;
      pointer-events: none;
    }

    .arrow-fray--top {
      top: 0;
    }

    .arrow-fray--bottom {
      top: auto;
      bottom: 0;
      transform: translateX(-50%) scaleY(-1);
    }

    .shape--segment-open .arrow-shaft {
      top: 0;
      bottom: 0;
      height: auto;
      width: 18px;
      border-radius: 9px;
      background: var(--arrow-color, var(--arrow-green));
      mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 82%, transparent 100%);
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 82%, transparent 100%);
    }

    .shape--image {
      border-radius: 16px;
    }

    .hidden {
      display: none !important;
    }

    .shape--label {
      --label-font-size: 14px;
      min-width: 140px;
      min-height: 48px;
    }

    .shape--label .shape__body {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      background: transparent;
      border: 0;
      border-radius: 0;
    }

    .shape--label[data-orientation="vertical"] .shape__body {
      padding: 0;
    }

    .shape--label .label-content {
      width: 100%;
      height: 100%;
      pointer-events: auto;
    }

    .shape--label .label-editor {
      position: relative;
      min-height: 1.2em;
      font-size: var(--label-font-size, 14px);
      font-family: inherit;
      color: var(--line-color);
      line-height: 1.35;
      text-align: center;
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .shape--label .label-editor[data-empty="true"]::before {
      content: attr(data-placeholder);
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(100, 116, 139, 0.82);
      pointer-events: none;
    }

    .shape--label[data-orientation="vertical"] .label-content {
      writing-mode: vertical-rl;
    }

    .shape--label[data-orientation="vertical"] .label-editor {
      transform: rotate(180deg);
    }

    .tools-panel__group--labels {
      display: grid;
      gap: 12px;
    }

    .label-controls {
      display: grid;
      gap: 12px;
    }

    .label-size {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }

    .label-size__btn,
    .label-orientation__btn {
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.05);
      color: #0f172a;
      font-size: 0.9rem;
      padding: 8px 10px;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .label-size__btn:hover:not(:disabled),
    .label-orientation__btn:hover:not(:disabled) {
      border-color: rgba(14, 165, 233, 0.5);
    }

    .label-size__btn[aria-pressed="true"],
    .label-orientation__btn[aria-pressed="true"] {
      border-color: rgba(14, 165, 233, 0.65);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.25);
      background: rgba(14, 165, 233, 0.12);
    }

    .label-size__btn:disabled,
    .label-orientation__btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .label-size__btn:active,
    .label-orientation__btn:active {
      transform: translateY(1px);
    }

    .shape--image .shape__body {
      overflow: visible;
    }

    .shape--image .image-frame {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 16px;
      overflow: hidden;
      background: #ffffff;
      box-shadow: 12px 0 28px rgba(15, 23, 42, 0.24);
    }

    .shape--image .image-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      border: 1px solid rgba(15, 23, 42, 0.08);
      border-radius: inherit;
    }

    .shape--image img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
    }









    .shape--arrow-up .arrow-shaft {

      top: 0;

      bottom: 0;

      height: auto;

      width: 18px;

      border-radius: 9px;

    }







    .shape--arrow-both .arrow-shaft {

      top: 0;

      bottom: 0;

      height: auto;

      width: 18px;

      border-radius: 9px;

    }







    .shape--arrow-both .arrow-head--bottom {



      bottom: 0;



    }







    .shape--line .shape__body {



      height: 2px;



      background: rgba(15, 23, 42, 0.75);



      border-radius: 2px;



    }



    .shape--arrow-double-slim .arrow-shaft {
      width: 2px;
      top: 12px;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--line-color);
      border-radius: 1px;
    }

    .shape--arrow-double-slim .arrow-head {
      top: 0;
      transform: translate(-50%, -65%);
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 10px solid var(--line-color);
    }

    .shape--arrow-double-slim .arrow-head--bottom {
      top: auto;
      bottom: 0;
      transform: translate(-50%, 65%);
      border-bottom: none;
      border-top: 10px solid var(--line-color);
    }










    @media (max-width: 1024px) {



      body {



        padding-left: clamp(140px, 26vw, 280px);



      }



      .workspace-viewport {



        padding-right: clamp(140px, 20vw, 220px);



      }



    }







    @media (max-width: 768px) {



      body {



        flex-direction: column;



        padding: clamp(16px, 4vw, 24px);



      }



      .tools-panel {



        position: static;



        width: 100%;



        display: flex;



        flex-wrap: wrap;



      }



      .workspace-viewport {



        padding: clamp(16px, 4vw, 24px);



      }



      .year-nav {



        position: sticky;



        top: auto;



        bottom: clamp(12px, 3vh, 24px);



        right: auto;



        margin-left: auto;



        transform: none;



        flex-direction: row;



      }



    }



  </style>



</head>



<body>



  <aside class="tools-panel" id="tools-panel">



    <h2>Werkzeuge</h2>



    <div class="tools-panel__group">



      <button type="button" class="tool-button" data-tool="arrow-both" aria-pressed="false">



        <span class="tool-preview">&#8661;</span>



        <span>Breiter Doppelpfeil</span>



      </button>

      <button type="button" class="tool-button" data-tool="segment-open" aria-pressed="false">
        <span class="tool-preview">~~</span>
        <span>Offener Abschnitt</span>
      </button>

      <button type="button" class="tool-button" data-tool="label" aria-pressed="false">
        <span class="tool-preview">Aa</span>
        <span>Beschriftung</span>
      </button>

      <button type="button" class="tool-button" data-tool="image" aria-pressed="false">
        <span class="tool-preview">Img</span>
        <span>Bild einfuegen</span>
      </button>





      <button type="button" class="tool-button" data-tool="arrow-double-slim" aria-pressed="false">



        <span class="tool-preview">&#8661;</span>



        <span>Feiner Doppelpfeil</span>



      </button>



      <button type="button" class="tool-button" data-tool="line" aria-pressed="false">



        <span class="tool-preview">&#9472;</span>



        <span>Horizontale Linie</span>



      </button>



    </div>



    <div class="tools-panel__group">



      <span style="font-size:0.85rem; opacity:0.85;">Farbe fuer breite Pfeile</span>



      <div class="color-palette" role="group" aria-label="Pfeilfarbe waehlen">



        <button type="button" class="color-swatch" data-color="green" aria-pressed="true" style="background: var(--arrow-green);"></button>



        <button type="button" class="color-swatch" data-color="yellow" aria-pressed="false" style="background: var(--arrow-yellow);"></button>



        <button type="button" class="color-swatch" data-color="red" aria-pressed="false" style="background: var(--arrow-red);"></button>



      </div>



    </div>





    <div class="tools-panel__group tools-panel__group--labels hidden" id="label-controls">
      <span style="font-size:0.85rem; opacity:0.85;">Einstellungen fuer Text</span>
      <div class="label-controls">
        <div class="label-size" role="group" aria-label="Schriftgroesse waehlen">
          <button type="button" class="label-size__btn" data-font-size="10" aria-pressed="false">10</button>
          <button type="button" class="label-size__btn" data-font-size="12" aria-pressed="false">12</button>
          <button type="button" class="label-size__btn" data-font-size="14" aria-pressed="false">14</button>
          <button type="button" class="label-size__btn" data-font-size="16" aria-pressed="false">16</button>
          <button type="button" class="label-size__btn" data-font-size="18" aria-pressed="false">18</button>
        </div>
        <button type="button" class="label-orientation__btn" data-orientation-toggle aria-pressed="false" aria-label="Ausrichtung wechseln">Horizontal</button>
      </div>
    </div>

    <div class="tools-panel__group">
      <span style="font-size:0.85rem; opacity:0.85;">Datei</span>
      <div class="file-controls">
        <button type="button" class="file-btn" data-file-action="export">Exportieren</button>
        <button type="button" class="file-btn" data-file-action="import">Importieren</button>
      </div>
    </div>

    <input type="file" id="workspace-import-input" accept="application/json" hidden />

    <input type="file" id="image-upload-input" accept="image/*" hidden />
  </aside>







  <section class="workspace-container">



    <div class="workspace-toolbar">



      <div class="zoom-controls" id="zoom-controls">



        <button type="button" data-zoom="out" aria-label="Verkleinern">-</button>



        <input type="range" id="zoom-slider" min="50" max="200" value="100" />



        <span class="zoom-controls__value" id="zoom-value">100%</span>



        <button type="button" data-zoom="in" aria-label="Vergroessern">+</button>



      </div>



    </div>







    <div class="workspace-viewport" id="workspace-viewport">



      <nav class="year-nav" id="year-nav" aria-label="Zeitsprung">
        <button type="button" data-year="-4050">-4050 v. Chr.</button>
        <button type="button" data-year="-2550">-2550 v. Chr.</button>
        <button type="button" data-year="-1050">-1050 v. Chr.</button>
        <button type="button" data-year="450">450 n. Chr.</button>
        <button type="button" data-year="2050">2050 n. Chr.</button>
      </nav>






      <div class="workspace" id="workspace">



        <div class="workspace-canvas" id="workspace-canvas">



          <div class="timeline-scale" id="timeline-scale"></div>



        </div>



      </div>



    </div>



  </section>







  <script type="module">



    const START_YEAR = -4050;



    const END_YEAR = 2050;



    const STEP = 10;



    const RANGE = END_YEAR - START_YEAR;

    const SEGMENT_OPEN_MIN_YEARS = 10;
    const SEGMENT_OPEN_MAX_YEARS = 2000;







    const zoomSlider = document.getElementById('zoom-slider');



    const zoomValue = document.getElementById('zoom-value');



    const zoomControls = document.getElementById('zoom-controls');



    const workspaceCanvas = document.getElementById('workspace-canvas');
    const workspace = document.getElementById('workspace');

    const workspaceViewport = document.getElementById('workspace-viewport');



    const timelineScale = document.getElementById('timeline-scale');



    const yearNav = document.getElementById('year-nav');



    const toolsPanel = document.getElementById('tools-panel');




    const imageInput = document.getElementById('image-upload-input');
    const workspaceImportInput = document.getElementById('workspace-import-input');
    const toolButtons = toolsPanel.querySelectorAll('[data-tool]');
    const fileActionButtons = toolsPanel.querySelectorAll('[data-file-action]');



    const colorButtons = toolsPanel.querySelectorAll('[data-color]');

    const labelControls = document.getElementById('label-controls');
    const labelFontButtons = labelControls ? Array.from(labelControls.querySelectorAll('[data-font-size]')) : [];
    const labelOrientationBtn = labelControls ? labelControls.querySelector('[data-orientation-toggle]') : null;

    let currentScale = 1;



    let currentArrowColor = 'green';



    let selectedShape = null;







    const COLOR_MAP = {



      green: getComputedStyle(document.documentElement).getPropertyValue('--arrow-green') || '#22c55e',



      yellow: getComputedStyle(document.documentElement).getPropertyValue('--arrow-yellow') || '#facc15',



      red: getComputedStyle(document.documentElement).getPropertyValue('--arrow-red') || '#ef4444',



    };







    const SHAPE_CONFIG = {






      'arrow-both': { width: 18, height: 280, minHeight: 140, maxHeight: 900 },



      'segment-open': { width: 18, height: 280, minHeight: 24, maxHeight: 5000 },



      'label': { width: 220, height: 120, minWidth: 120, maxWidth: 720, minHeight: 48, maxHeight: 480 },



      image: { width: 280, height: 180, minWidth: 120, maxWidth: 960, minHeight: 80, maxHeight: 720 },



      'arrow-double-slim': { width: 20, height: 260, minHeight: 12, maxHeight: 900 },



      line: { width: 240, height: 2, minWidth: 80, maxWidth: 900 },



    };







    const POSITION_PADDING = 8;



    const STORAGE_KEY = 'timeline-workspace-state-v1';
    const SAVE_DEBOUNCE_MS = 300;
    let saveTimerId = null;
    let isRestoringState = false;

    const storageAvailable = (() => {
      try {
        const testKey = '__timeline_state_test__';
        window.localStorage.setItem(testKey, '1');
        window.localStorage.removeItem(testKey);
        return true;
      } catch (error) {
        console.warn('Lokaler Speicher steht nicht zur Verfuegung, Fortschritt wird nicht gespeichert.', error);
        return false;
      }
    })();







    const pointerState = {



      mode: null,



      shape: null,



      pointerId: null,



      startX: 0,



      startY: 0,



      startLeft: 0,



      startTop: 0,



      startWidth: 0,



      startHeight: 0,



      offsetX: 0,



      offsetY: 0,



    };







    function formatYear(value) {



      if (value < 0) {



        return `${Math.abs(value)} v. Chr.`;



      }



      return `${value} n. Chr.`;



    }







    function tickClassForYear(year) {



      if (year % 500 === 0) return 'tick tick--major';



      if (year % 100 === 0) return 'tick tick--minor';



      if (year % 50 === 0) return 'tick tick--micro';



      return 'tick tick--mini';



    }







    function renderScale() {



      timelineScale.innerHTML = '';







      for (let year = START_YEAR; year <= END_YEAR; year += STEP) {



        const ratio = (END_YEAR - year) / RANGE;



        const tick = document.createElement('div');



        tick.dataset.year = year;







        let tickClass = 'tick tick--mini';



        let showLabel = false;







        if (year % 500 === 0) {



          tickClass = 'tick tick--major';



          showLabel = true;



        } else if (year % 100 === 0) {



          tickClass = 'tick tick--minor';



          showLabel = true;



        } else if (year % 50 === 0) {



          tickClass = 'tick tick--micro';



          showLabel = true;



        }







        tick.className = tickClass;



        tick.style.top = `${ratio * 100}%`;







        const line = document.createElement('span');



        line.className = 'tick__line';



        tick.append(line);







        if (showLabel) {



          const label = document.createElement('span');



          label.className = 'tick__label';



          label.textContent = formatYear(year);



          tick.append(label);



        }







        timelineScale.appendChild(tick);



      }



    }

    function syncWorkspaceHeight() {

      if (!workspaceCanvas || !workspace || !timelineScale) return;

      const scaleHeight = timelineScale.scrollHeight;
      if (!Number.isFinite(scaleHeight) || scaleHeight <= 0) return;

      const minHeight = scaleHeight + 'px';
      workspaceCanvas.style.minHeight = minHeight;
      workspace.style.minHeight = minHeight;

    }

    function updateSegmentOpenBounds() {

      const segmentConfig = SHAPE_CONFIG['segment-open'];
      if (!segmentConfig || !timelineScale) return;

      const styles = getComputedStyle(timelineScale);
      const paddingTop = parseFloat(styles.paddingTop) || 0;
      const paddingBottom = parseFloat(styles.paddingBottom) || 0;
      const usableHeight = timelineScale.clientHeight - paddingTop - paddingBottom;
      if (usableHeight <= 0) return;

      const pxPerYear = usableHeight / RANGE;
      segmentConfig.minHeight = Math.max(Math.round(pxPerYear * SEGMENT_OPEN_MIN_YEARS), 8);
      segmentConfig.maxHeight = Math.max(segmentConfig.minHeight, Math.round(Math.min(pxPerYear * SEGMENT_OPEN_MAX_YEARS, usableHeight)));

    }








    function applyZoom(scale) {



      const clamped = Math.min(Math.max(scale, 0.5), 2.5);



      currentScale = clamped;



      workspaceCanvas.style.transform = `scale(${currentScale})`;



      zoomSlider.value = Math.round(currentScale * 100);



      zoomValue.textContent = `${Math.round(currentScale * 100)}%`;
      syncWorkspaceHeight();



    }







    function scrollToYear(year) {



      const clampedYear = Math.min(Math.max(year, START_YEAR), END_YEAR);



      const tick = timelineScale.querySelector(`[data-year="${clampedYear}"]`);



      if (!tick) return;







      const viewportRect = workspaceViewport.getBoundingClientRect();



      const tickRect = tick.getBoundingClientRect();



      const offset = tickRect.top - viewportRect.top;



      const target = workspaceViewport.scrollTop + offset - workspaceViewport.clientHeight / 2;



      const maxScroll = workspaceViewport.scrollHeight - workspaceViewport.clientHeight;







      workspaceViewport.scrollTo({



        top: Math.min(Math.max(target, 0), Math.max(maxScroll, 0)),



        behavior: 'smooth',



      });



    }







    function getLocalPoint(event) {



      const rect = workspaceCanvas.getBoundingClientRect();



      return {



        x: (event.clientX - rect.left) / currentScale,



        y: (event.clientY - rect.top) / currentScale,



      };



    }







    function setShapePosition(shape, left, top) {



      const width = shape.offsetWidth;



      const height = shape.offsetHeight;



      const canvasWidth = workspaceCanvas.offsetWidth;



      const canvasHeight = workspaceCanvas.offsetHeight;



      const maxLeft = Math.max(canvasWidth - width, 0);



      const maxTop = Math.max(canvasHeight - height, 0);







      let clampedLeft = clamp(left, -POSITION_PADDING, maxLeft + POSITION_PADDING);



      let clampedTop = clamp(top, -POSITION_PADDING, maxTop + POSITION_PADDING);







      if (clampedLeft + width > canvasWidth + POSITION_PADDING) {



        clampedLeft = canvasWidth + POSITION_PADDING - width;



      }



      if (clampedLeft < -POSITION_PADDING) {



        clampedLeft = -POSITION_PADDING;



      }



      if (clampedTop + height > canvasHeight + POSITION_PADDING) {



        clampedTop = canvasHeight + POSITION_PADDING - height;



      }



      if (clampedTop < -POSITION_PADDING) {



        clampedTop = -POSITION_PADDING;



      }







      shape.dataset.x = `${clampedLeft}`;



      shape.dataset.y = `${clampedTop}`;



      shape.style.left = `${clampedLeft}px`;



      shape.style.top = `${clampedTop}px`;



    }







    function setShapeSize(shape, width, height) {



      if (typeof width === 'number') {



        shape.style.width = `${width}px`;



      }



      if (typeof height === 'number') {



        shape.style.height = `${height}px`;



      }



    }







    function bringToFront(shape) {



      const maxZ = Array.from(workspaceCanvas.querySelectorAll('.shape'))



        .reduce((acc, el) => Math.max(acc, parseInt(el.style.zIndex || '12', 10)), 12);



      shape.style.zIndex = String(maxZ + 1);



    }







    function clearSelection() {

      if (selectedShape) {
        selectedShape.classList.remove('shape--selected');
        selectedShape = null;
      }

      updateLabelControls(null);

      scheduleSave();

    }







    function selectShape(shape) {

      if (selectedShape === shape) return;

      clearSelection();

      selectedShape = shape;

      shape.classList.add('shape--selected');

      updateLabelControls(shape);

    }







    function setArrowColor(shape, colorKey) {



      if (!COLOR_MAP[colorKey]) return;



      shape.style.setProperty('--arrow-color', COLOR_MAP[colorKey]);



      shape.dataset.color = colorKey;



    }







    function updateColorControls(colorKey) {

      colorButtons.forEach((button) => {
        const isActive = button.dataset.color === colorKey;
        button.setAttribute('aria-pressed', String(isActive));
      });

    }

    function serializeShape(shape) {

      if (!shape) return null;
      const type = shape.dataset.type;
      if (!type) return null;

      const width = Math.round(shape.offsetWidth);
      const height = Math.round(shape.offsetHeight);
      const rawX = shape.dataset.x ?? shape.style.left ?? '0';
      const rawY = shape.dataset.y ?? shape.style.top ?? '0';
      const x = Number.parseFloat(rawX) || 0;
      const y = Number.parseFloat(rawY) || 0;
      const zIndexValue = Number.parseInt(shape.style.zIndex || '0', 10);

      const data = {
        type,
        x,
        y,
        width,
        height,
        zIndex: Number.isFinite(zIndexValue) ? zIndexValue : 0,
      };

      if (shape.dataset.color) {
        data.color = shape.dataset.color;
      }

      if (type === 'label') {
        const editor = shape.querySelector('.label-editor');
        data.text = editor ? editor.textContent || '' : '';
        data.fontSize = Number(shape.dataset.fontSize) || 14;
        data.orientation = shape.dataset.orientation === 'vertical' ? 'vertical' : 'horizontal';
      } else if (type === 'image') {
        const img = shape.querySelector('img');
        if (!img || !img.src) {
          return null;
        }
        data.src = img.src;
        data.alt = img.alt || '';
        if (shape.dataset.aspect) {
          const aspect = Number.parseFloat(shape.dataset.aspect);
          if (Number.isFinite(aspect)) {
            data.aspect = aspect;
          }
        }
      }

      return data;

    }

    function serializeWorkspace() {

      const shapes = Array.from(workspaceCanvas.querySelectorAll('.shape'))
        .map(serializeShape)
        .filter(Boolean);

      return {
        version: 1,
        scale: currentScale,
        scrollTop: workspaceViewport.scrollTop,
        shapes,
      };

    }

    function saveWorkspaceState() {

      if (isRestoringState) return;
      const state = serializeWorkspace();
      if (!state) return;

      if (storageAvailable) {
        try {
          window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (error) {
          console.warn('Speichern des Arbeitsbereichs ist fehlgeschlagen.', error);
        }
      }

    }

    function scheduleSave() {

      if (!storageAvailable || isRestoringState) return;
      if (saveTimerId) {
        window.clearTimeout(saveTimerId);
      }
      saveTimerId = window.setTimeout(saveWorkspaceState, SAVE_DEBOUNCE_MS);

    }

    function createShapeFromState(data) {

      if (!data || !data.type) return null;
      let shape = null;

      if (data.type === 'line') {
        shape = createLine();
      } else if (data.type === 'label') {
        shape = createLabelShape();
        const editor = shape.querySelector('.label-editor');
        if (editor) {
          editor.textContent = data.text || '';
          editor.dataset.empty = editor.textContent.trim().length === 0 ? 'true' : 'false';
        }
        shape.dataset.fontSize = String(data.fontSize ?? 14);
        shape.dataset.orientation = data.orientation === 'vertical' ? 'vertical' : 'horizontal';
        shape.dataset.editing = 'false';
        applyLabelStyles(shape);
      } else if (data.type === 'image') {
        if (!data.src) return null;
        shape = createImageShape(data.src, data.alt || '');
        if (typeof data.aspect === 'number' && Number.isFinite(data.aspect)) {
          shape.dataset.aspect = String(data.aspect);
        }
      } else {
        shape = createArrow(data.type);
        if (data.color) {
          setArrowColor(shape, data.color);
        }
      }

      return shape;

    }

    function applyWorkspaceState(state, { skipSave = false } = {}) {

      if (!state || !Array.isArray(state.shapes)) return false;

      isRestoringState = true;

      try {
        workspaceCanvas.querySelectorAll('.shape').forEach((shape) => shape.remove());

        state.shapes.forEach((shapeData) => {
          const shape = createShapeFromState(shapeData);
          if (!shape) return;

          workspaceCanvas.appendChild(shape);

          const width = Number.isFinite(shapeData.width) ? shapeData.width : null;
          const height = Number.isFinite(shapeData.height) ? shapeData.height : null;
          if (width !== null || height !== null) {
            setShapeSize(shape, width, height);
          }

          const x = Number.isFinite(shapeData.x) ? shapeData.x : 0;
          const y = Number.isFinite(shapeData.y) ? shapeData.y : 0;
          setShapePosition(shape, x, y);

          if (Number.isFinite(shapeData.zIndex)) {
            shape.style.zIndex = String(shapeData.zIndex);
          }
        });

        clearSelection();

        if (Number.isFinite(state.scale)) {
          applyZoom(state.scale);
        }

        if (Number.isFinite(state.scrollTop)) {
          workspaceViewport.scrollTop = state.scrollTop;
        }
      } finally {
        isRestoringState = false;
      }

      if (!skipSave) {
        saveWorkspaceState();
      }

      return true;

    }

    function restoreWorkspaceState() {

      if (!storageAvailable) return;

      let raw = null;
      try {
        raw = window.localStorage.getItem(STORAGE_KEY);
      } catch (error) {
        console.warn('Gespeicherter Arbeitsbereich kann nicht gelesen werden.', error);
        return;
      }

      if (!raw) return;

      let state = null;
      try {
        state = JSON.parse(raw);
      } catch (error) {
        console.warn('Gespeicherter Arbeitsbereich ist ungueltig.', error);
        return;
      }

      applyWorkspaceState(state, { skipSave: true });
      syncWorkspaceHeight();

    }

    function getWorkspaceExportFilename() {

      const now = new Date();
      const iso = now.toISOString().replace(/[:.]/g, '-');
      return `timeline-workspace-${iso}.json`;

    }

    function exportWorkspaceAsFile() {

      try {
        const state = serializeWorkspace();
        if (!state) {
          window.alert('Export fehlgeschlagen - kein gueltiger Arbeitsbereich.');
          return;
        }
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = getWorkspaceExportFilename();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Export fehlgeschlagen', error);
        window.alert('Export fehlgeschlagen. Bitte versuchen Sie es erneut.');
      }

    }

    function importWorkspaceFromFile(file) {

      if (!file) return;

      const reader = new FileReader();
      reader.addEventListener('error', () => {
        console.error('Datei konnte nicht gelesen werden.', reader.error);
        window.alert('Die Datei konnte nicht gelesen werden.');
        if (workspaceImportInput) {
          workspaceImportInput.value = '';
        }
      });
      reader.addEventListener('load', (event) => {
        try {
          const content = typeof event.target?.result === 'string' ? event.target.result : '';
          if (!content) {
            throw new Error('Leerer Inhalt');
          }
          const parsed = JSON.parse(content);
          if (!parsed || typeof parsed !== 'object') {
            throw new Error('Ungueltiges Format');
          }

          const hasShapes = workspaceCanvas.querySelector('.shape');
          if (hasShapes) {
            const confirmed = window.confirm('Aktueller Arbeitsbereich wird ueberschrieben. Fortfahren?');
            if (!confirmed) {
              return;
            }
          }

          const applied = applyWorkspaceState(parsed);
          if (!applied) {
            window.alert('Die Datei konnte nicht importiert werden.');
          }
        } catch (error) {
          console.error('Import fehlgeschlagen', error);
          window.alert('Import fehlgeschlagen. Bitte pruefen Sie die Datei.');
        } finally {
          if (workspaceImportInput) {
            workspaceImportInput.value = '';
          }
        }
      });
      reader.readAsText(file, 'utf-8');

    }

function removeSelectedShape() {

      if (!selectedShape) return;
      if (selectedShape.dataset && selectedShape.dataset.type === 'label' && selectedShape.dataset.editing === 'true') return;

      if (pointerState.shape === selectedShape) {

        pointerState.mode = null;

        pointerState.shape = null;

        pointerState.pointerId = null;

        pointerState.offsetX = 0;

        pointerState.offsetY = 0;

      }

      selectedShape.remove();

      selectedShape = null;

      updateLabelControls(null);

    }







    function createArrow(type) {



      const shape = document.createElement('div');



      shape.className = `shape shape--${type}`;



      shape.dataset.type = type;



      let topElement = '';
      let bottomElement = '';

      if (type === 'segment-open') {
        topElement = '';
        bottomElement = '';
      } else if (type === 'arrow-double-slim') {
        topElement = '<div class="arrow-head"></div>';
        bottomElement = '<div class="arrow-head arrow-head--bottom"></div>';
      }



      shape.innerHTML = `



        <div class="shape__body">



          ${topElement}



          <div class="arrow-shaft"></div>



          ${bottomElement}



        </div>



        <div class="shape__handle shape__handle--top" data-handle="top" aria-label="Laenge anpassen"></div>



        <div class="shape__handle shape__handle--bottom" data-handle="bottom" aria-label="Laenge anpassen"></div>



      `;



      return shape;



    }







    function createLine() {



      const shape = document.createElement('div');



      shape.className = 'shape shape--line';



      shape.dataset.type = 'line';



      shape.innerHTML = `



        <div class="shape__body"></div>



        <div class="shape__handle shape__handle--left" data-handle="left" aria-label="Ende verschieben"></div>



        <div class="shape__handle shape__handle--right" data-handle="right" aria-label="Ende verschieben"></div>



      `;



      return shape;



    }








    function createImageShape(src, altText) {

      const shape = document.createElement('div');
      shape.className = 'shape shape--image';
      shape.dataset.type = 'image';

      shape.innerHTML = `
        <div class="shape__body">
          <div class="image-frame">
            <img src="${src}" alt="" draggable="false" />
          </div>
        </div>
        <div class="shape__handle shape__handle--top" data-handle="top" aria-label="Hoehe anpassen"></div>
        <div class="shape__handle shape__handle--bottom" data-handle="bottom" aria-label="Hoehe anpassen"></div>
        <div class="shape__handle shape__handle--left" data-handle="left" aria-label="Breite anpassen"></div>
        <div class="shape__handle shape__handle--right" data-handle="right" aria-label="Breite anpassen"></div>
      `;

      const img = shape.querySelector('img');
      if (img) {
        img.alt = altText || '';
      }

      return shape;

    }

    function createLabelShape() {

      const shape = document.createElement('div');
      shape.className = 'shape shape--label';
      shape.dataset.type = 'label';
      shape.dataset.fontSize = '14';
      shape.dataset.orientation = 'horizontal';
      shape.dataset.editing = 'true';

      shape.innerHTML = `
        <div class="shape__body">
          <div class="label-content">
            <div class="label-editor" data-placeholder="Beschriftung..." data-empty="true" contenteditable="true"></div>
          </div>
        </div>
        <div class="shape__handle shape__handle--top" data-handle="top" aria-label="Hoehe anpassen"></div>
        <div class="shape__handle shape__handle--bottom" data-handle="bottom" aria-label="Hoehe anpassen"></div>
        <div class="shape__handle shape__handle--left" data-handle="left" aria-label="Breite anpassen"></div>
        <div class="shape__handle shape__handle--right" data-handle="right" aria-label="Breite anpassen"></div>
      `;

      applyLabelStyles(shape);
      setupLabelShape(shape);
      return shape;

    }

    function applyLabelStyles(shape) {

      if (!shape || shape.dataset.type !== 'label') return;
      const fontSize = Number(shape.dataset.fontSize) || 14;
      shape.style.setProperty('--label-font-size', `${fontSize}px`);
      const orientation = shape.dataset.orientation === 'vertical' ? 'vertical' : 'horizontal';
      shape.dataset.orientation = orientation;
    }

    function setupLabelShape(shape) {

      const editor = shape.querySelector('.label-editor');
      if (!editor) return;

      const updateEmptyState = () => {
        editor.dataset.empty = editor.textContent.trim().length === 0 ? 'true' : 'false';
      };

      editor.addEventListener('pointerdown', (event) => {
        if (shape.dataset.editing === 'true') {
          event.stopPropagation();
        }
      });

      editor.addEventListener('dblclick', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (shape.dataset.editing !== 'true') {
          enterLabelEdit(shape);
        }
      });

      editor.addEventListener('input', () => {
        updateEmptyState();
      });

      editor.addEventListener('keydown', (event) => {
        event.stopPropagation();
        if (event.key === 'Escape') {
          event.preventDefault();
          exitLabelEdit(shape);
          editor.blur();
        } else if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
          event.preventDefault();
          editor.blur();
        }
      });

      editor.addEventListener('focus', () => {
        shape.dataset.editing = 'true';
      });

      editor.addEventListener('blur', () => {
        exitLabelEdit(shape);
      });

      updateEmptyState();
    }

    function enterLabelEdit(shape) {

      if (!shape || shape.dataset.type !== 'label') return;
      const editor = shape.querySelector('.label-editor');
      if (!editor) return;
      shape.dataset.editing = 'true';
      editor.contentEditable = 'true';
      if (selectedShape !== shape) {
        selectShape(shape);
      }
      requestAnimationFrame(() => {
        editor.focus({ preventScroll: true });
        placeCaretAtEnd(editor);
      });
    }

    function exitLabelEdit(shape) {

      if (!shape || shape.dataset.type !== 'label') return;
      if (shape.dataset.editing !== 'true') return;
      const editor = shape.querySelector('.label-editor');
      if (!editor) return;
      shape.dataset.editing = 'false';
      editor.contentEditable = 'false';
      const text = editor.textContent || '';
      editor.dataset.empty = text.trim().length === 0 ? 'true' : 'false';
      applyLabelStyles(shape);
      updateLabelControls(shape);
      scheduleSave();
    }

    function placeCaretAtEnd(node) {

      const selection = window.getSelection();
      if (!selection) return;
      const range = document.createRange();
      range.selectNodeContents(node);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function setLabelFontSize(shape, value) {

      if (!shape || shape.dataset.type !== 'label') return;
      const size = clamp(Number(value) || 14, 10, 18);
      shape.dataset.fontSize = String(size);
      applyLabelStyles(shape);
      updateLabelControls(shape);
      scheduleSave();
    }



    function toggleLabelOrientation(shape) {

      if (!shape || shape.dataset.type !== 'label') return;
      const current = shape.dataset.orientation === 'vertical' ? 'vertical' : 'horizontal';
      const next = current === 'horizontal' ? 'vertical' : 'horizontal';
      shape.dataset.orientation = next;
      applyLabelStyles(shape);
      updateLabelControls(shape);
      scheduleSave();
    }



    function updateLabelControls(shape) {

      if (!labelControls) return;
      const isLabel = !!(shape && shape.dataset && shape.dataset.type === 'label');
      labelControls.classList.toggle('hidden', !isLabel);
      const fontSize = isLabel ? Number(shape.dataset.fontSize) || 14 : null;
      labelFontButtons.forEach((button) => {
        const targetSize = Number(button.dataset.fontSize);
        const isActive = isLabel && targetSize === fontSize;
        button.setAttribute('aria-pressed', String(isActive));
        button.disabled = !isLabel;
      });
      if (labelOrientationBtn) {
        if (isLabel) {
          const orientation = shape.dataset.orientation === 'vertical' ? 'vertical' : 'horizontal';
          const isVertical = orientation === 'vertical';
          labelOrientationBtn.disabled = false;
          labelOrientationBtn.textContent = isVertical ? 'Vertikal (von unten nach oben)' : 'Horizontal';
          labelOrientationBtn.setAttribute('aria-pressed', String(isVertical));
        } else {
          labelOrientationBtn.disabled = true;
          labelOrientationBtn.textContent = 'Horizontal';
          labelOrientationBtn.setAttribute('aria-pressed', 'false');
        }
      }
    }



    function placeShape(shape, type, initialSize) {



      const config = SHAPE_CONFIG[type] || {};



      const width = typeof initialSize?.width === 'number' ? initialSize.width : (config.width ?? shape.offsetWidth ?? 200);



      const height = typeof initialSize?.height === 'number' ? initialSize.height : (config.height ?? shape.offsetHeight ?? 200);



      setShapeSize(shape, width, height);







      const canvasWidth = workspaceCanvas.offsetWidth;



      const shapeWidth = width;



      const shapeHeight = height;







      const left = (canvasWidth - shapeWidth) / 2;



      const localScrollTop = workspaceViewport.scrollTop / currentScale;



      const centerOffset = workspaceViewport.clientHeight / (2 * currentScale);



      const top = Math.max(localScrollTop + centerOffset - shapeHeight / 2, 0);







      setShapePosition(shape, left, top);



      bringToFront(shape);



      workspaceCanvas.appendChild(shape);



      selectShape(shape);

      return shape;

    }







    function createShape(type) {

      let shape;

      if (type === 'line') {

        shape = createLine();

      } else if (type === 'label') {

        shape = createLabelShape();

      } else {

        shape = createArrow(type);

        if (type === 'arrow-both' || type === 'segment-open') {

          setArrowColor(shape, currentArrowColor);

        }

      }

      const placedShape = placeShape(shape, type);

      if (type === 'label') {
        enterLabelEdit(placedShape);
      }

      scheduleSave();

    }







        function handleToolClick(event) {

      const button = event.currentTarget;
      const tool = button.dataset.tool;

      if (tool === 'image') {
        toolButtons.forEach((btn) => btn.setAttribute('aria-pressed', 'false'));
        if (imageInput) {
          imageInput.value = '';
          imageInput.click();
        }
        return;
      }

      createShape(tool);
      toolButtons.forEach((btn) => btn.setAttribute('aria-pressed', String(btn === button)));

    }

    toolButtons.forEach((button) => button.addEventListener('click', handleToolClick));

    colorButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const color = button.dataset.color;

        currentArrowColor = color;
        updateColorControls(color);

        if (selectedShape) {
          const type = selectedShape.dataset.type;
          if (type === 'arrow-both' || type === 'segment-open') {
            setArrowColor(selectedShape, color);
          }
        }

        scheduleSave();
      });
    });

    fileActionButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const action = button.dataset.fileAction;
        if (action === 'export') {
          exportWorkspaceAsFile();
        } else if (action === 'import') {
          if (workspaceImportInput) {
            workspaceImportInput.value = '';
            workspaceImportInput.click();
          }
        }
      });
    });

    if (workspaceImportInput) {
      workspaceImportInput.addEventListener('change', () => {
        const file = workspaceImportInput.files && workspaceImportInput.files[0];
        if (!file) return;
        importWorkspaceFromFile(file);
      });
    }

    labelFontButtons.forEach((button) => {
      button.addEventListener('click', () => {
        if (!selectedShape || selectedShape.dataset.type !== 'label') return;
        setLabelFontSize(selectedShape, button.dataset.fontSize);
        scheduleSave();
      });
    });

    if (labelOrientationBtn) {
      labelOrientationBtn.addEventListener('click', () => {
        if (!selectedShape || selectedShape.dataset.type !== 'label') return;
        toggleLabelOrientation(selectedShape);
        scheduleSave();
      });
    }

    updateLabelControls(null);


    if (imageInput) {
      imageInput.addEventListener('change', () => {
        toolButtons.forEach((btn) => btn.setAttribute('aria-pressed', 'false'));
        const file = imageInput.files && imageInput.files[0];
        if (!file) {
          return;
        }
        if (!file.type.startsWith('image/')) {
          console.warn('Nur Bilddateien koennen eingefuegt werden.');
          imageInput.value = '';
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          if (typeof result !== 'string') {
            imageInput.value = '';
            return;
          }
          const img = new Image();
          img.onload = () => {
            const naturalWidth = img.naturalWidth || img.width || 1;
            const naturalHeight = img.naturalHeight || img.height || 1;
            const aspect = naturalWidth > 0 && naturalHeight > 0 ? naturalWidth / naturalHeight : 1;
            const config = SHAPE_CONFIG.image || {};
            const minWidth = config.minWidth ?? 120;
            const maxWidth = config.maxWidth ?? 960;
            const minHeight = config.minHeight ?? 80;
            const maxHeight = config.maxHeight ?? 720;
            let width = naturalWidth > 0 ? naturalWidth : (config.width ?? 280);
            let height = naturalHeight > 0 ? naturalHeight : (config.height ?? 180);
            const downScale = Math.min(maxWidth / width, maxHeight / height, 1);
            const upScale = Math.max(minWidth / width, minHeight / height, 1);
            let scale = 1;
            if (downScale < 1) {
              scale = downScale;
            } else if (upScale > 1 && Number.isFinite(upScale)) {
              scale = upScale;
            }
            if (!Number.isFinite(scale) || scale <= 0) {
              scale = 1;
            }
            width = Math.round(width * scale);
            height = Math.round(height * scale);
            const ratio = aspect > 0 ? aspect : (width / Math.max(height, 1));
            const clampToBounds = () => {
              if (width < minWidth) {
                width = minWidth;
                height = Math.round(width / ratio);
              }
              if (height < minHeight) {
                height = minHeight;
                width = Math.round(height * ratio);
              }
              if (width > maxWidth) {
                width = maxWidth;
                height = Math.round(width / ratio);
              }
              if (height > maxHeight) {
                height = maxHeight;
                width = Math.round(height * ratio);
              }
            };
            clampToBounds();
            clampToBounds();
            if (!(width > 0) || !(height > 0)) {
              width = config.width ?? 280;
              height = config.height ?? 180;
            }
            let altText = (file.name || 'Bild').split('\\').pop() || 'Bild';
            altText = altText.split('/').pop();
            altText = altText || 'Bild';
            const shape = createImageShape(result, altText);
            shape.dataset.aspect = (width / height).toFixed(4);
            placeShape(shape, 'image', { width, height });
            scheduleSave();
            imageInput.value = '';
          };
          img.onerror = () => {
            console.error('Bild konnte nicht geladen werden.');
            imageInput.value = '';
          };
          img.src = result;
        };
        reader.onerror = () => {
          console.error('Datei konnte nicht gelesen werden.');
          imageInput.value = '';
        };
        reader.readAsDataURL(file);
      });
    }

window.addEventListener('keydown', handleKeyDown);







    function clamp(value, min, max) {



      return Math.min(Math.max(value, min), max);



    }







    function handleKeyDown(event) {



      if (!selectedShape) return;



      const target = event.target;



      if (target instanceof HTMLElement) {



        const tag = target.tagName;



        if (tag === 'INPUT' || tag === 'TEXTAREA' || target.isContentEditable) {



          return;



        }



      }



      if (event.key === 'Delete' || event.key === 'Backspace') {



        event.preventDefault();



        removeSelectedShape();



      }



    }







    function handlePointerDown(event) {



      if (!(event.target instanceof Element)) return;



      const handle = event.target.closest('[data-handle]');



      const shape = event.target.closest('.shape');

      if (selectedShape && selectedShape !== shape && selectedShape.dataset && selectedShape.dataset.type === 'label' && selectedShape.dataset.editing === 'true') {
        exitLabelEdit(selectedShape);
      }

      if (shape && shape.dataset && shape.dataset.type === 'label' && shape.dataset.editing === 'true') {
        const editor = shape.querySelector('.label-editor');
        if (!editor || !editor.contains(event.target)) {
          exitLabelEdit(shape);
        }
      }








      if (!shape || !workspaceCanvas.contains(shape)) {



        clearSelection();



        return;



      }







      event.preventDefault();



      selectShape(shape);



      bringToFront(shape);







      const local = getLocalPoint(event);



      pointerState.shape = shape;



      pointerState.pointerId = event.pointerId ?? 'mouse';



      pointerState.startX = local.x;



      pointerState.startY = local.y;



      pointerState.startLeft = parseFloat(shape.dataset.x || '0');



      pointerState.startTop = parseFloat(shape.dataset.y || '0');



      pointerState.startWidth = shape.offsetWidth;



      pointerState.startHeight = shape.offsetHeight;







      if (handle) {



        pointerState.mode = handle.dataset.handle;



      } else {



        pointerState.mode = 'move';



        pointerState.offsetX = local.x - pointerState.startLeft;



        pointerState.offsetY = local.y - pointerState.startTop;



      }







      if (shape.setPointerCapture && event.pointerId !== undefined) {



        try {



          shape.setPointerCapture(event.pointerId);



        } catch (_) {



          /* ignore */



        }



      }



    }







    function handlePointerMove(event) {



      if (!pointerState.shape || pointerState.pointerId === null) return;



      if (event.pointerId !== undefined && pointerState.pointerId !== 'mouse' && event.pointerId !== pointerState.pointerId) return;







      const shape = pointerState.shape;



      const type = shape.dataset.type;



      const local = getLocalPoint(event);







      if (pointerState.mode === 'move') {



        const newLeft = local.x - pointerState.offsetX;



        const newTop = local.y - pointerState.offsetY;



        setShapePosition(shape, newLeft, newTop);



        return;



      }







      const config = SHAPE_CONFIG[type];



      if (!config) return;







      if (pointerState.mode === 'top') {



        const delta = local.y - pointerState.startY;



        const nextHeight = clamp(pointerState.startHeight - delta, config.minHeight, config.maxHeight);



        const heightDelta = pointerState.startHeight - nextHeight;



        const nextTop = pointerState.startTop + heightDelta;



        setShapeSize(shape, null, nextHeight);



        setShapePosition(shape, pointerState.startLeft, nextTop);



      } else if (pointerState.mode === 'bottom') {



        const delta = local.y - pointerState.startY;



        const nextHeight = clamp(pointerState.startHeight + delta, config.minHeight, config.maxHeight);



        setShapeSize(shape, null, nextHeight);



      } else if (pointerState.mode === 'left') {



        const delta = local.x - pointerState.startX;



        const rightEdge = pointerState.startLeft + pointerState.startWidth;



        let newLeft = pointerState.startLeft + delta;



        const minWidth = config.minWidth ?? 20;



        const maxWidth = config.maxWidth ?? Infinity;







        newLeft = clamp(newLeft, -POSITION_PADDING, rightEdge - minWidth);



        let width = rightEdge - newLeft;



        const canvasWidth = workspaceCanvas.offsetWidth;



        const maxByCanvas = Math.max(canvasWidth + POSITION_PADDING - newLeft, minWidth);



        width = clamp(width, minWidth, Math.min(maxWidth, maxByCanvas));



        newLeft = clamp(newLeft, -POSITION_PADDING, canvasWidth + POSITION_PADDING - width);







        setShapeSize(shape, width, null);



        setShapePosition(shape, newLeft, pointerState.startTop);



      } else if (pointerState.mode === 'right') {



        const delta = local.x - pointerState.startX;



        const minWidth = config.minWidth ?? 20;



        const maxWidth = config.maxWidth ?? Infinity;



        const canvasWidth = workspaceCanvas.offsetWidth;



        const maxByCanvas = Math.max(canvasWidth + POSITION_PADDING - pointerState.startLeft, minWidth);



        const width = clamp(pointerState.startWidth + delta, minWidth, Math.min(maxWidth, maxByCanvas));



        setShapeSize(shape, width, null);



        const newLeft = clamp(pointerState.startLeft, -POSITION_PADDING, canvasWidth + POSITION_PADDING - width);



        setShapePosition(shape, newLeft, pointerState.startTop);



      }



    }







    function handlePointerUp(event) {

      if (!pointerState.shape) return;

      if (event.pointerId !== undefined && pointerState.pointerId !== 'mouse' && event.pointerId !== pointerState.pointerId) return;

      if (pointerState.shape.releasePointerCapture && event.pointerId !== undefined) {

        try {

          pointerState.shape.releasePointerCapture(event.pointerId);

        } catch (_) {

          /* ignore */

        }

      }

      pointerState.mode = null;

      pointerState.shape = null;

      pointerState.pointerId = null;

      pointerState.offsetX = 0;

      pointerState.offsetY = 0;

      scheduleSave();

    }


    workspaceCanvas.addEventListener('pointerdown', handlePointerDown);



    window.addEventListener('pointermove', handlePointerMove, { passive: false });



    window.addEventListener('pointerup', handlePointerUp);



    window.addEventListener('pointercancel', handlePointerUp);

    window.addEventListener('resize', () => {
      syncWorkspaceHeight();
      updateSegmentOpenBounds();
    });







    renderScale();
    syncWorkspaceHeight();
    updateSegmentOpenBounds();




    applyZoom(currentScale);

    restoreWorkspaceState();







    zoomSlider.addEventListener('input', (event) => {

      applyZoom(event.target.value / 100);
      scheduleSave();

    });



    zoomControls.querySelectorAll('button[data-zoom]').forEach((button) => {

      button.addEventListener('click', () => {

        const direction = button.dataset.zoom === 'in' ? 1 : -1;

        applyZoom(currentScale + 0.1 * direction);
        scheduleSave();

      });

    });



    workspaceViewport.addEventListener('wheel', (event) => {

      if (!event.ctrlKey) return;

      event.preventDefault();

      const delta = event.deltaY < 0 ? 0.1 : -0.1;

      applyZoom(currentScale + delta);
      scheduleSave();

    }, { passive: false });

    workspaceViewport.addEventListener('scroll', () => {
      scheduleSave();
    });



    yearNav.querySelectorAll('button[data-year]').forEach((button) => {



      button.addEventListener('click', () => {



        const year = Number(button.dataset.year);



        scrollToYear(year);



      });



    });



  </script>



</body>



</html>
